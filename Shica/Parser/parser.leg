%{
#ifndef PARSER_C
#define PARSER_C

#include <stdlib.h>
#include <string.h>
#include "parser.h"

#define YYSTYPE node
YYSTYPE result;

#define YY_FREE(C, P) P = NULL

node parserRetFlags[3] = {
	MAKE_OOP_FLAG(PARSER_FINISH),
	MAKE_OOP_FLAG(PARSER_ERROR),
	MAKE_OOP_FLAG(PARSER_READY),
};




static int nlines = 1;
//LEG AREA
%}

start	=  - s:state {result = s;}
		|  - s:define { result = s; }
        | !.                              { printf("\n%d objects allocated\n", nobj); result = parserRetFlags[PARSER_FINISH]; }
		| < (!eol &. .)* >                { fatal("line %d: syntax error: %s", nlines, yytext); result = parserRetFlags[PARSER_ERROR]; reportError(ERROR, nlines, "syntax error: %s", yytext); }

state = STATE i:id p:params e:events { $$ = newState(i, p, e,nlines); }

events = LBRACE b:mkBlock
	  (
	    !RBRACE
	    (e:event|e:stt_local_assignment)              { Event_Block_append(b, e) }
	  )+
	  RBRACE			{ $$ = b }

event = i:id p:eparams b:block { $$ = newEvent(i, p, b, nlines); }
	  | i:id DOT f:id  p:eparams b:block { $$ = newEvent(newGetField(i, f, nlines), p, b, nlines); }

eparams	= LPAR p:mkNil
	  ( t:TYPE i:id c:mkFalse (c:eqop)?			{ p = newEparams(t, i, c, p) }
	    ( COMMA t:TYPE i:id	c:mkFalse (c:eqop)?	{ p = newEparams(t, i, c, p) }
	    )*
	  )?
 	  RPAR				{ $$ = p }

params	= LPAR p:mkNil
	  ( t:TYPE i:id			{ p = newParams(t, i, p) }
	    ( COMMA t:TYPE i:id		{ p = newParams(t, i, p) }
	    )*
	  )?
 	  RPAR				{ $$ = p }

mkNil	= 				{ $$ = nil }
mkFalse = 				{ $$ = FALSE }

block   = LBRACE b:mkBlock
	  (
	    !RBRACE
	    s:stmt                      { Block_append(b, s) }
	  )+
	  RBRACE			{ $$ = b }

mkBlock =                               { $$ = newBlock() }

define = t:TYPE i:id p:params b:block { $$ = newSetVar(t,i, newUserFunc(p, b),0, nlines); } #/*func*/
       | t:TYPE i:id ASSIGN x:eqop SEMI { $$ = newSetVar(t,i, x, SCOPE_GLOBAL, nlines) }
       | t:TYPE v:value i:indexes ASSIGN x:eqop SEMI { $$ = newSetArray(t,v, i, x, SCOPE_GLOBAL, nlines); }

stmt =  PRINT a:args SEMI     	  { $$ = newPrint(a, nlines) }	
		| IF LPAR c:expr RPAR (s:expr | s:block )
	  		ELSE (t:expr | t:block)          	  { $$ = newIf(c, s, t) }
		| IF LPAR c:expr RPAR (s:block|s:expr)	  { $$ = newIf(c, s, FALSE) }
		| WHILE LPAR c:expr RPAR (s:stmt|s:block)	  { $$ = newLoop(FALSE, c,FALSE, s) }
		| FOR LPAR (i:expr|i:mkFalse) SEMI 
		  		   (c:expr|c:mkFalse) SEMI 
		  		   (t:expr|k:mkFalse) RPAR 
		  (s:block|s:expr)	  { $$ = newLoop(i, c, t, s) }
		| RET (x:expr | x:mkFalse) SEMI			  { $$ = newReturn(x); }
		| STATE i:id SEMI                 { $$ = newTransition(i); }
		| x:expr SEMI			  		  { result = x; }
		| - SEMI				  		

args	= LPAR a:mkNil
	  ( i:expr			{ a = newArgs(i, a) }
	    ( COMMA i:expr		{ a = newArgs(i, a) }
	    )*
	  )?
 	  RPAR				{ $$ = a }

expr	= assignment

stt_local_assignment = t:TYPE i:id ASSIGN x:assignment { $$ = newSetVar(t, i, x, SCOPE_STATE_LOCAL, nlines) }
	  			     | t:TYPE v:value i:indexes ASSIGN x:assignment { $$ = newSetArray(t, v, i, x, SCOPE_STATE_LOCAL, nlines); }

assignment  = (t:TYPE | t:mkNil) i:id ASSIGN x:assignment			{ $$ = newSetVar(t, i, x, SCOPE_LOCAL, nlines) }
			| (t:TYPE | t:mkNil) v:value i:indexes ASSIGN x:assignment	{ $$ = newSetArray(t, v, i, x, SCOPE_LOCAL, nlines); }
			| eqop

eqop    = lhs:ineq ( EQUAL rhs:ineq	{ lhs = newBinop(EQ, lhs, rhs) }
	  	   | NOTEQ rhs:ineq	{ lhs = newBinop(NE, lhs, rhs) }
	  	  )*			{ $$ = lhs }

ineq    = lhs:add ( GREATER rhs:add	{ lhs = newBinop(GT, lhs, rhs) }
	          | GREATEQ rhs:add	{ lhs = newBinop(GE, lhs, rhs) }
	          | LESSEQ  rhs:add	{ lhs = newBinop(LE, lhs, rhs) }
	          | LESS    rhs:add	{ lhs = newBinop(LT, lhs, rhs) }
	  	  )*			{ $$ = lhs }

add	= lhs:mul ( PLUS   rhs:mul	{ lhs = newBinop(ADD, lhs, rhs) }
	  	  | MINUS  rhs:mul	{ lhs = newBinop(SUB, lhs, rhs) }
	  	  )*			{ $$ = lhs }

mul	= lhs:prefix ( STAR  rhs:prefix	{ lhs = newBinop(MUL, lhs, rhs) }
	  	     | SLASH rhs:prefix	{ lhs = newBinop(DIV, lhs, rhs) }
	  	     | PCENT rhs:prefix	{ lhs = newBinop(MOD, lhs, rhs) }
	  	     )*			{ $$ = lhs }


prefix	= MINUS x:postfix		{ $$ = newUnyop(NEG, x) }
		| PLING x:postfix		{ $$ = newUnyop(NOT, x) }
		| PPLUS x:postfix		{ $$ = newUnyop(BINC, x) }
		| MMINUS x:postfix		{ $$ = newUnyop(BDEC, x) }
		| postfix

postfix = v:value PPLUS { $$ = newUnyop(AINC, v) }
		| v:value MMINUS{ $$ = newUnyop(ADEC, v) }
		| v:value ( a:args		{ v = newCall(a, v, nlines) }
	    		  | i:indexes		{ v = newGetArray(v, i, nlines) }
	  	  			)*			{ $$ = v }

indexes = i:index p:mkNil { p = newPair(i, p) }
		( i:index		  { p = newPair(i, p) }
	  )* { $$ = p }

index	= LBRAK e:expr RBRAK		{ $$ = e }

value	= LPAR lhs:expr  RPAR		{ $$ = lhs }
	| integer
	| string 
	| i:id DOT e:postfix { $$ = newGetField(i, e, nlines); }
	| i:id		{ $$ = newGetVar(i,nlines); }
	| array

array	= LBRACE a:mkArray
	  ( e:expr			{ Array_append(a, e) }
	    ( COMMA e:expr		{ Array_append(a, e) }
	    )* )? RBRACE			{ $$ = a }
mkArray	=      	  			{ $$ = newArray(0) }

integer	= < [0-9]+ > -  		{ $$ = newInteger(atoi(yytext)) }

float_	= < ( [0-9]+            expnt
	    | [0-9]+ '.' [0-9]* expnt?
	    | [0-9]* '.' [0-9]+ expnt?
	    ) > -			{ $$ = newFloat(yytext) }

expnt	= 'e' [-+]? [0-9]+

string	= DQUOTE < alnumsym* > DQUOTE -	{ $$ = newString(yytext); }
id	= < alpha alnum* > -		{ $$ = intern(yytext);  }

alpha	= [a-zA-Z_]
alnum	= [a-zA-Z_0-9]
symbol =  [+\-*/%<>=!] 
alnumsym =  [a-zA-Z_0-9+\-*/%<>=!: ]
-	= blank*

blank	= [ \t]
	| newline
	| '//' (![\n\r] .)*

eol	= [\r\n]

newline = [\n\r] { nlines++;}

COMMA	= ","       -
SEMI	= ";"       -
ASSIGN	= "=" !"="  -
EQUAL   = "=="	    -
NOTEQ   = "!="      -
LESS    = "<" ![=<] -
LESSEQ  = "<="      -
GREATEQ = ">="      -
GREATER = ">" ![=>] -
PLUS	= "+" !"+"  -
PPLUS	= "++" !"+" 
MINUS	= "-" !"-"  -
MMINUS  = "--" !"-"
STAR	= "*" 	    -
SLASH	= "/" 	    -
PCENT	= "%" 	    -
LPAR	= "(" 	    -
RPAR	= ")" 	    -
LBRACE  = "{" 	    -
RBRACE  = "}" 	    -
LBRAK   = "[" 	    -
RBRAK   = "]" 	    -
PLING	= "!" !"="  -

QUOTE   = "\'"      
DQUOTE  = "\"" 
DOT   = "."

STATE = "stt" -
IF    = "if" -
ELSE  = "else" -
PRINT = "print" -
WHILE = "while" -
FOR   = "for" -

RET = "return" -

TYPE = VAR | INT | FLO | STR | FUNC 

FUNC = "fn" - 
VAR = "var" - { $$ = TYPES[Undefined]; }
INT = "int" - { $$ = TYPES[Integer]; }
FLO = "flo" - { $$ = TYPES[Float]; }
STR = "str" - { $$ = TYPES[String]; }

%%;
void initLine(void)
{
	nlines = 0;
}

void initYYContext()
{
    yyrelease(yyctx);
}

#ifdef MSGC
void collectYYContext()
{
	if(yyctx){
		gc_markOnly(yyctx);
		// char     *__buf;
		// int       __buflen;
		gc_markOnly(yyctx->__buf);
		// int       __pos;
		// int       __limit;
		// char     *__text;
		// int       __textlen;
		gc_markOnly(yyctx->__text);
		// int       __begin;
		// int       __end;
		// int       __textmax;
		// yythunk  *__thunks;
		// int       __thunkslen;
		// int       __thunkpos;
		gc_markOnly(yyctx->__thunks);
// 		for(int i=0; i<yyctx->__thunkslen;i++){
// // typedef struct _yythunk { int begin, end;  yyaction  action;  struct _yythunk *next; } yythunk;
// 			gc_markOnly(yyctx->__thunks[i].next)
// 			//action is function pointer
// 			//next is maybe not need ...
// 		}
		// YYSTYPE   __;
		// YYSTYPE  *__val;
		// YYSTYPE  *__vals;
		// int       __valslen;
		#undef yy
		#undef __
		gc_mark(yyctx->__);
		gc_mark(yyctx->__val);
		for(int i=0;i<yyctx->__valslen;i++){
			gc_mark(yyctx->__vals[i]);
		}
	}
}
#elif defined(MSGCS)
void collectYYContext()
{
	if(yyctx){
		gc_markOnly(yyctx);
		// char     *__buf;
		// int       __buflen;
		gc_markOnly(yyctx->__buf);
		// int       __pos;
		// int       __limit;
		// char     *__text;
		// int       __textlen;
		gc_markOnly(yyctx->__text);
		// int       __begin;
		// int       __end;
		// int       __textmax;
		// yythunk  *__thunks;
		// int       __thunkslen;
		// int       __thunkpos;
		gc_markOnly(yyctx->__thunks);
// 		for(int i=0; i<yyctx->__thunkslen;i++){
// // typedef struct _yythunk { int begin, end;  yyaction  action;  struct _yythunk *next; } yythunk;
// 			gc_markOnly(yyctx->__thunks[i].next)
// 			//action is function pointer
// 			//next is maybe not need ...
// 		}
		// YYSTYPE   __;
		// YYSTYPE  *__val;
		// YYSTYPE  *__vals;
		// int       __valslen;
		#undef yy
		#undef __
		gc_mark(yyctx->__);
		gc_mark(yyctx->__val);
		for(int i=0;i<yyctx->__valslen;i++){
			gc_mark(yyctx->__vals[i]);
		}
	}
}
#else
   #error "GC is not defined, please define MSGC or MSGCS or add your own GC"
#endif // GC_SECTION

#endif // PARSER_H